use crate::{ Alphabate, Encode, Decode };
use std::iter::FromIterator;

// Alphabate of Base16
pub struct Base16;
const BASE16_ENCODE_ALPHABATE: [char; 16] = [
     '0', '1', '2', '3', '4', '5', '6', '7',
     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
];
const BASE16_DECODE_ALPHABATE: [u8; 256] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//                                                                    '+' ,       '-' ,       '/' ,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//  '0' , '1' , '2' , '3',  '4' , '5' , '6' , '7' , '8' , '9' ,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//       'A' , 'B' , 'C' , 'D',  'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  'O' ,
    0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//  'P' , 'Q' , 'R' , 'S' , 'T' , 'U',  'V' , 'W' , 'X' , 'Y' , 'Z' ,                         '_' ,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

impl Alphabate for Base16 {
    fn get_character_from_index(index: u8) -> Option<char> {
        Some(BASE16_ENCODE_ALPHABATE[index as usize])
    }
    fn get_index_from_character(character: char) -> Option<u8> {
        Some(BASE16_DECODE_ALPHABATE[character as usize])
    }
}

// Encoder and Decoder for Base16
struct Encoder<T: Alphabate>(T);
impl<T: Alphabate> Encoder<T> {
    fn split(chunk: &[u8]) -> Vec<u8> {
        match chunk.len() {
            1 => vec![
                chunk[0] >> 4,
                chunk[0] & 0b0000_1111,
            ],
            _ => unreachable!(),
        }
    }
    fn encode_chunk(chunk: &[u8]) -> Vec<char> {
        let mut out = [T::pad(); 2];
        for i in 0..chunk.len() {
            if let Some(character) = 
                T::get_character_from_index(chunk[i]) {
                    out[i] = character;
                }
        }
        return out.to_vec();
    }
}

struct Decoder<T: Alphabate>(T);
impl<T: Alphabate> Decoder<T> {
    fn stitch(chunk: &[u8]) -> Vec<u8> {
        let out = match chunk.len() {
            2 => vec![
                chunk[0] << 4 | (chunk[1] & 0b0000_1111),
            ],
            _ => unreachable!(),
        };
        return out.into_iter().filter(|&x| x > 0).collect();
    }
    fn decode_chunk(chunk: &[char]) -> Vec<u8> {
        chunk
            .iter()
            .filter(|character| **character != T::pad())
            .map(|character| {
                T::get_index_from_character(*character).unwrap()
            })
            .collect()
    }
}

// impl trait for Base16
impl Encode for Base16 {
    fn encode(data: &[u8]) -> String {
        let encoded = data
            .chunks(1)
            .map(|chunk| Encoder::<Self>::split(&chunk))
            .flat_map(|chunk| Encoder::<Self>::encode_chunk(&chunk));
        return String::from_iter(encoded);
    }
}
impl Decode for Base16 {
    fn decode(code: &str) -> Vec<u8> {
        if code.chars().count() % 2 != 0 {
            println!("Error: Need padding")
        }
        code
            .chars()
            .collect::<Vec<char>>()
            .chunks(2)
            .map(|chunk| Decoder::<Self>::decode_chunk(&chunk))
            .flat_map(|chunk| Decoder::<Self>::stitch(&chunk))
            .collect()
    }
}
