use crate::{ Alphabate, Encode, Decode };
use std::iter::FromIterator;

// Alphabate of Base64 and Base64URL
pub struct Base64;
const BASE64_ENCODE_ALPHABATE: [char; 64] = [
     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
     'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
     'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
     'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
     'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
     'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
     'w', 'x', 'y', 'z', '0', '1', '2', '3',
     '4', '5', '6', '7', '8', '9', '+', '-',
];
const BASE64_DECODE_ALPHABATE: [u8; 256] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//                                                                    '+' ,       '-' ,       '/' ,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0x3f, 0xff, 0xff,
//  '0' , '1' , '2' , '3',  '4' , '5' , '6' , '7' , '8' , '9' ,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//       'A' , 'B' , 'C' , 'D',  'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  'O' ,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
//  'P' , 'Q' , 'R' , 'S' , 'T' , 'U',  'V' , 'W' , 'X' , 'Y' , 'Z' ,                         '_' ,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
//        'a' , 'b' , 'c' , 'd' , 'e',  'f' , 'g' , 'h' , 'i' , 'g' , 'k' , 'l' , 'm' , 'n' , 'o' ,
    0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
//  'p' , 'q' , 'r' , 's' , 't' , 'u',  'v' , 'w' , 'x' , 'y' , 'z'                                
    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

pub struct Base64URL;
const BASE64URL_ENCODE_ALPHABATE: [char; 64] = [
     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
     'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
     'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
     'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
     'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
     'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
     'w', 'x', 'y', 'z', '0', '1', '2', '3',
     '4', '5', '6', '7', '8', '9', '-', '_',
];
const BASE64URL_DECODE_ALPHABATE: [u8; 256] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//                                                                    '+' ,       '-' ,       '/' ,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff,
//  '0' , '1' , '2' , '3',  '4' , '5' , '6' , '7' , '8' , '9' ,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//       'A' , 'B' , 'C' , 'D',  'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  'O' ,
    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
//  'P' , 'Q' , 'R' , 'S' , 'T' , 'U',  'V' , 'W' , 'X' , 'Y' , 'Z' ,                         '_' ,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0x3f,
//        'a' , 'b' , 'c' , 'd' , 'e',  'f' , 'g' , 'h' , 'i' , 'g' , 'k' , 'l' , 'm' , 'n' , 'o' ,
    0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
//  'p' , 'q' , 'r' , 's' , 't' , 'u',  'v' , 'w' , 'x' , 'y' , 'z'                                
    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
];

impl Alphabate for Base64 {
    fn get_character_from_index(index: u8) -> Option<char> {
        Some(BASE64_ENCODE_ALPHABATE[index as usize])
    }
    fn get_index_from_character(character: char) -> Option<u8> {
        Some(BASE64_DECODE_ALPHABATE[character as usize])
    }
}

impl Alphabate for Base64URL {
    fn get_character_from_index(index: u8) -> Option<char> {
        Some(BASE64URL_ENCODE_ALPHABATE[index as usize])
    }
    fn get_index_from_character(character: char) -> Option<u8> {
        Some(BASE64URL_DECODE_ALPHABATE[character as usize])
    }
}

// Encoder and Decoder for Base64 or Base64URL
struct Encoder<T: Alphabate>(T);
impl<T: Alphabate> Encoder<T> {
    fn split(chunk: &[u8]) -> Vec<u8> {
        match chunk.len() {
            1 => vec![
                &chunk[0] >> 2,
                (&chunk[0] & 0b0000_0011) << 4
            ],
            2 => vec![
                &chunk[0] >> 2, 
                (&chunk[0] & 0b0000_0011) << 4 | &chunk[1] >> 4,
                (&chunk[1] & 0b0000_1111) << 2,
            ],
            3 => vec![
                &chunk[0] >> 2, 
                (&chunk[0] & 0b0000_0011) << 4 | &chunk[1] >> 4,
                (&chunk[1] & 0b0000_1111) << 2 | &chunk[2] >> 6,
                (&chunk[2] & 0b0011_1111),
            ],
            _ => unreachable!(),
        }
    }
    fn encode_chunk(chunk: &[u8]) -> Vec<char> {
        let mut out = [T::pad(); 4];
        for i in 0..chunk.len() {
            if let Some(character) = 
                T::get_character_from_index(chunk[i]) {
                    out[i] = character;
                }
        }
        return out.to_vec();
    }
}

struct Decoder<T: Alphabate>(T);
impl<T: Alphabate> Decoder<T> {
    fn stitch(chunk: &[u8]) -> Vec<u8> {
        let out = match chunk.len() {
            2 => vec![
                (chunk[0] & 0b0011_1111) << 2 | chunk[1] >> 4,
                (chunk[1] & 0b0000_1111) << 4
            ],
            3 => vec![
                (chunk[0] & 0b0011_1111) << 2 | chunk[1] >> 4,
                (chunk[1] & 0b0000_1111) << 4 | chunk[2] >> 2,
                (chunk[2] & 0b0000_0011) << 6,
            ],
            4 => vec![
                (chunk[0] & 0b0011_1111) << 2 | chunk[1] >> 4,
                (chunk[1] & 0b0000_1111) << 4 | chunk[2] >> 2,
                (chunk[2] & 0b0000_0011) << 6 | chunk[3] & 0b0011_1111,
            ],
            _ => unreachable!(),
        };
        return out.into_iter().filter(|&x| x > 0).collect();
    }
    fn decode_chunk(chunk: &[char]) -> Vec<u8> {
        chunk
            .iter()
            .filter(|character| **character != T::pad())
            .map(|character| {
                T::get_index_from_character(*character).unwrap()
            })
            .collect()
    }
}

// impl trait for Base64 or Base64URL
impl Encode for Base64 {
    fn encode(data: &[u8]) -> String {
        let encoded = data
            .chunks(3)
            .map(|chunk| Encoder::<Self>::split(&chunk))
            .flat_map(|chunk| Encoder::<Self>::encode_chunk(&chunk));
        return String::from_iter(encoded);
    }
}
impl Encode for Base64URL {
    fn encode(data: &[u8]) -> String {
        let encoded = data
            .chunks(3)
            .map(|chunk| Encoder::<Self>::split(&chunk))
            .flat_map(|chunk| Encoder::<Self>::encode_chunk(&chunk));
        return String::from_iter(encoded);
    }
}

impl Decode for Base64 {
    fn decode(code: &str) -> Vec<u8> {
        if code.chars().count() % 4 != 0 {
            println!("Error: Need padding")
        }
        code
            .chars()
            .collect::<Vec<char>>()
            .chunks(4)
            .map(|chunk| Decoder::<Self>::decode_chunk(&chunk))
            .flat_map(|chunk| Decoder::<Self>::stitch(&chunk))
            .collect()
    }
}
impl Decode for Base64URL {
    fn decode(code: &str) -> Vec<u8> {
        if code.chars().count() % 4 != 0 {
            println!("Error: Need padding")
        }
        code
            .chars()
            .collect::<Vec<char>>()
            .chunks(4)
            .map(|chunk| Decoder::<Self>::decode_chunk(&chunk))
            .flat_map(|chunk| Decoder::<Self>::stitch(&chunk))
            .collect()
    }
}
